
![image](https://github.com/GreatMengChongKing/leetcode-master/assets/117571588/11ea865d-dd8f-4649-a28a-c948dc69ace3)
# 理论基础
如果某一问题有很多重叠子问题，使用动态规划是最有效的。难点:找到分解的子问题，且无后效性。  
动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的  
**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**  
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组
# 简单斐波那契
## 斐波那契数
[斐波那契数列](./problems/0509.斐波那契数.md)  
dp[i]含义就是第i个斐波那契数  
递推公式dp[i]=dp[i-1]+dp[i-2];  
初始化dp[0]=0,dp[1]=1  
从前向后遍历  
## 爬楼梯
[爬楼梯](./problems/0070.爬楼梯.md)
dp[i]就是表示爬i个台阶的方法数
递推公式dp[i]=dp[i-1]+dp[i-2]，因为每次只能爬一级或两级    
初始化dp[0]=1,dp[1]=1  
其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1。  
从前向后遍历  
## 使用最小花费爬楼梯
[使用最小花费爬楼梯](./problems/0746.使用最小花费爬楼梯.md)
dp[i]含义就是爬到第i层所需最小花费  
递推公式dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);  
可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。  
dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。  
dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。  
初始化dp[0]=0,dp[1]=0    
从前向后遍历  
## 不同路径
[不同路径](./problems/0062.不同路径.md)
dp[i][j]表示从(0,0)到(i,j)的路径数
递推公式dp[i][j]=dp[i-1][j]+dp[i][j-1]  
初始化dp[0][i]=1,dp[i][0]=1   
遍历顺序从左往右，从上到下  
还可以使用组合数求解  
## 不同路径2
[不同路径2](./problems/0063.不同路径II.md)  
dp[i][j]表示从(0,0)到(i,j)的路径数
递推公式dp[i][j]=dp[i-1][j]+dp[i][j-1],(i,j)有障碍就不进行递推  
初始化dp[0][i]=1,dp[i][0]=1，有障碍的话，障碍后面的dp[][]都是零      
遍历顺序从左往右，从上到下  
**attention**  
## 整数拆分
[整数拆分](./problems/0343.整数拆分.md)  
dp[i]含义就是i拆分后的最大乘积  
递推公式dp[i]=max({dp[i], (i - j) * j, dp[i - j] * j})    
其实可以从1遍历j，然后有两种渠道得到dp[i].
一个是j * (i - j) 直接相乘。
一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。
初始化dp[2] = 1        
从前向后遍历  
**error**  
## 不同的二叉搜索树
[不同的二叉搜索树](.problems/0096.不同的二叉搜索树.md)  
dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。
dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量  
初始化dp[0] = 1  
从前到后遍历  
**error**  
# 01背包
背包问题
![image](https://github.com/GreatMengChongKing/leetcode-master/assets/117571588/4426e26b-fc7b-4e7f-88fb-21ac969902ea)

## 理论基础
有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
### 二维dp数组
1.确定dp数组以及下标的含义
对于背包问题，有一种写法，是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
2.确定递推公式
那么可以有两个方向推出来dp[i][j]，  
不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)  
放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值  
所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);  
3.dp数组如何初始化  
那么很明显当 j < weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。  
当j >= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。  
4.遍历顺序  
先遍历物品还是先遍历背包重量，其实都可以！！ 但是先遍历物品更好理解。  
### 一维滚动dp数组
在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);  
其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);  
与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。  
1.确定dp数组的定义
在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。
2.一维dp数组的递推公式
dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。  
dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）  
此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，  
所以递归公式为：  
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);  
可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。  
3.初始化  
关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。  
假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。  
4.**遍历顺序**  
二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。  
先物品后背包，倒序遍历背包(为了每个物品只放一次)  
所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！  
在后面背包问题的讲解中，我都直接使用一维dp数组来进行推导。  
## 分割等和子集
[分割等和子集](./problems/0416.分割等和子集.md)  
dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]。  
如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 dp[target] == target 的时候，背包就装满了  
递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);    
本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。  
所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);  
首先dp[0]一定是0。  
如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。    
如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！  
如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。  
**01背包相对于本题，主要要理解，题目中物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2。**  

