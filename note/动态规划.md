
![image](https://github.com/GreatMengChongKing/leetcode-master/assets/117571588/11ea865d-dd8f-4649-a28a-c948dc69ace3)
# 理论基础
如果某一问题有很多重叠子问题，使用动态规划是最有效的。难点:找到分解的子问题，且无后效性。  
动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的  
**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**  
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组
# 简单斐波那契
## 斐波那契数
[斐波那契数列](./problems/0509.斐波那契数.md)  
dp[i]含义就是第i个斐波那契数  
递推公式dp[i]=dp[i-1]+dp[i-2];  
初始化dp[0]=0,dp[1]=1  
从前向后遍历  
## 爬楼梯
[爬楼梯](./problems/0070.爬楼梯.md)
dp[i]就是表示爬i个台阶的方法数
递推公式dp[i]=dp[i-1]+dp[i-2]，因为每次只能爬一级或两级    
初始化dp[0]=1,dp[1]=1  
其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1。  
从前向后遍历  
## 使用最小花费爬楼梯
[使用最小花费爬楼梯](./problems/0746.使用最小花费爬楼梯.md)
dp[i]含义就是爬到第i层所需最小花费  
递推公式dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);  
可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。  
dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。  
dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。  
初始化dp[0]=0,dp[1]=0    
从前向后遍历  
## 不同路径
[不同路径](./problems/0062.不同路径.md)
dp[i][j]表示从(0,0)到(i,j)的路径数
递推公式dp[i][j]=dp[i-1][j]+dp[i][j-1]  
初始化dp[0][i]=1,dp[i][0]=1   
遍历顺序从左往右，从上到下  
还可以使用组合数求解  
## 不同路径2
[不同路径2](./problems/0063.不同路径II.md)  
dp[i][j]表示从(0,0)到(i,j)的路径数
递推公式dp[i][j]=dp[i-1][j]+dp[i][j-1],(i,j)有障碍就不进行递推  
初始化dp[0][i]=1,dp[i][0]=1，有障碍的话，障碍后面的dp[][]都是零      
遍历顺序从左往右，从上到下  
**attention**  
## 整数拆分
[整数拆分](./problems/0343.整数拆分.md)  
dp[i]含义就是i拆分后的最大乘积  
递推公式dp[i]=max({dp[i], (i - j) * j, dp[i - j] * j})    
其实可以从1遍历j，然后有两种渠道得到dp[i].
一个是j * (i - j) 直接相乘。
一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。
初始化dp[2] = 1        
从前向后遍历  
**error**  
## 不同的二叉搜索树
[不同的二叉搜索树](.problems/0096.不同的二叉搜索树.md)  
dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。
dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量  
初始化dp[0] = 1  
从前到后遍历  
**error**  

